/-
Copyright (c) 2025 Jiedong Jiang, Christian Merten. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johan Commelin, Jiedong Jiang, Christian Merten
-/
module

public import Mathlib.Topology.Spectral.Basic
public import Mathlib.Topology.JacobsonSpace
public import Mathlib.Data.Set.Card

/-!
# Constructible topology

In this file we define the constructible topology on a topological space. This is the topology
generated by compact open subsets and their complements.

## Main definitions and results

- `WithConstructibleTopology`: `X` equipped with its constructible topology.
- `compactSpace_withConstructibleTopology`: If `X` is quasi-separated, quasi-sober,
  prespectral and quasi-compact, then `X` is still quasi-compact in the constructible topology.

## TODOs

- If `X` is a spectral space, show that `X` is T2 and totally disconnected (@chrisflav).
-/

@[expose] public section

variable {X : Type*} [TopologicalSpace X]

/-- The subbasis of the constructible topology on a topological space `X`: It consists
of the open and compact sets of `X` and their complements. -/
def constructibleTopologySubbasis (X : Type*) [TopologicalSpace X] : Set (Set X) :=
  { s | IsOpen s âˆ§ IsCompact s } âˆª { s | IsClosed s âˆ§ IsCompact sá¶œ }

/-- The constructible topology on a topological space `X` has as a subbasis
the open and compact sets of `X` and their complements. -/
def constructibleTopology (X : Type*) [TopologicalSpace X] : TopologicalSpace X :=
  .generateFrom (constructibleTopologySubbasis X)

/-- A type synonym for `X` that is equipped with the constructible topology of `X`. -/
@[nolint unusedArguments]
def WithConstructibleTopology (X : Type*) [TopologicalSpace X] : Type _ :=
  X

instance : TopologicalSpace (WithConstructibleTopology X) :=
  constructibleTopology X

open Topology

lemma IsCompact.isOpen_constructibleTopology_of_isOpen {s : Set X}
    (hs : IsCompact s) (ho : IsOpen s) : IsOpen[constructibleTopology X] s := by
  apply TopologicalSpace.isOpen_generateFrom_of_mem
  simp [constructibleTopologySubbasis, ho, hs]

lemma IsCompact.isOpen_constructibleTopology_of_isClosed {s : Set X}
    (hs : IsCompact sá¶œ) (ho : IsClosed s) : IsOpen[constructibleTopology X] s := by
  apply TopologicalSpace.isOpen_generateFrom_of_mem
  simp [constructibleTopologySubbasis, ho, hs]

@[simp]
lemma compl_mem_constructibleTopologySubbasis_iff {s : Set X} :
    sá¶œ âˆˆ constructibleTopologySubbasis X â†” s âˆˆ constructibleTopologySubbasis X := by
  grind [constructibleTopologySubbasis, isClosed_compl_iff, compl_compl]

lemma isCompact_of_mem_constructibleTopologySubbasis [CompactSpace X] {s : Set X}
    (hs : s âˆˆ constructibleTopologySubbasis X) : IsCompact s := by
  obtain (hs | hs) := hs
  Â· exact hs.2
  Â· exact hs.1.isCompact

lemma isCompact_sInter_of_subset_constructibleTopologySubbasis [CompactSpace X]
    [QuasiSeparatedSpace X] {s : Set (Set X)} (hs : s âŠ† constructibleTopologySubbasis X)
    (hf : s.Finite) : IsCompact (â‹‚â‚€ s) := by
  refine QuasiSeparatedSpace.isCompact_sInter hf (fun t ht â†¦ ?_) (fun t ht â†¦ ?_)
  Â· apply (hs ht).imp <;> grind
  Â· exact isCompact_of_mem_constructibleTopologySubbasis (hs ht)

/-- If `X` is quasi-separated, quasi-sober, prespectral and quasi-compact, then `X`
is still quasi-compact in the constructible topology. This holds in particular for spectral
spaces. -/
@[stacks 0901 "quasi-compactness"]
instance compactSpace_withConstructibleTopology [CompactSpace X] [QuasiSober X]
    [PrespectralSpace X] [QuasiSeparatedSpace X] :
    CompactSpace (WithConstructibleTopology X) := by
  let ğ”… := constructibleTopologySubbasis X
  /- It suffices to check that any subset of `ğ”…` for which every finite subset has non-empty
  intersection, has non-empty intersection. We argue by contradiction and by Zorn's
  lemma, we may take a maximal counterexample `B`. -/
  apply compactSpace_generateFrom_of_compl_mem (T := constructibleTopology X) ğ”… rfl (by simp [ğ”…])
  let ğ’® := {P : Set (Set X) | P âŠ† ğ”… âˆ§ (âˆ€ Q âŠ† P, Q.Finite â†’ (â‹‚â‚€ Q).Nonempty) âˆ§ (â‹‚â‚€ P) = âˆ…}
  suffices ğ’® = âˆ… by contrapose! this; tauto
  by_contra! hğ’®
  obtain âŸ¨s, hsâŸ© := hğ’®
  obtain âŸ¨B, hsB, hBâŸ© := by
    refine zorn_subset_nonempty ğ’® (fun c hcğ’® hc hne@âŸ¨x, hxcâŸ© â†¦ ?_) s hs
    refine âŸ¨â‹ƒâ‚€ c, ?_, fun S hSc â†¦ Set.subset_sUnion_of_subset c S subset_rfl hScâŸ©
    refine âŸ¨by grind, fun a hac ha â†¦ ?_, by grindâŸ©
    obtain âŸ¨i, hmem, hsubâŸ© := hc.directedOn.exists_mem_subset_of_finite_of_subset_sUnion hne ha hac
    exact (hcğ’® hmem).2.1 a hsub ha
  let B' := {s | s âˆˆ B âˆ§ IsClosed s}
  /- Let `Z` be the intersection of all closed sets in `B`. We argue
  by cases if `Z` is irreducible or not. -/
  let Z := â‹‚â‚€ B'
  have hZ_closed : IsClosed Z := isClosed_sInter fun b hb â†¦ hb.2
  have hZ_nonempty : Z.Nonempty :=
    CompactSpace.nonempty_sInter (fun _ ht â†¦ ht.2) fun t ht hf â†¦
      hB.prop.2.1 _ (subset_trans ht (by simp [B'])) hf
  by_cases hZ_irred : IsIrreducible Z
  Â· -- If `Z` is irreducible, the intersection `â‹‚â‚€ B` contains the generic point of `Z`.
    suffices (â‹‚â‚€ B).Nonempty by simp_all [hB.prop.2.2]
    have hÎ· := hZ_irred.isGenericPoint_genericPoint (isClosed_sInter fun b hb â†¦ hb.2)
    refine âŸ¨hZ_irred.genericPoint, ?_âŸ©
    rw [Set.mem_sInter]
    intro i hi
    by_cases hiB' : i âˆˆ B'
    Â· exact Set.sInter_subset_of_mem hiB' hÎ·.mem
    Â· have hi_cmpt : IsCompact i := by grind [hB.prop, constructibleTopologySubbasis]
      rw [hÎ·.mem_open_set_iff (by grind [hB.prop, constructibleTopologySubbasis]), Set.inter_comm]
      refine hi_cmpt.nonempty_inter_sInter (fun _ hb â†¦ hb.2) fun a ha hfa â†¦ ?_
      rw [â† Set.sInter_insert]
      exact hB.prop.2.1 _ (by grind) (by simpa)
  Â· -- If `Z` is reducible, there exist closed compacts `Yâ‚` and `Yâ‚‚` such that `Z âŠ† Yâ‚ âˆª Yâ‚‚`.
    simp only [IsIrreducible, hZ_nonempty, true_and] at hZ_irred
    obtain âŸ¨Yâ‚, Yâ‚‚, hYâ‚_cl, hYâ‚‚_cl, hcâ‚, hcâ‚‚, hsub, âŸ¨xâ‚, hxâ‚âŸ©, âŸ¨xâ‚‚, hxâ‚‚âŸ©âŸ© :=
      PrespectralSpace.exists_isClosed_of_not_isPreirreducible _ hZ_irred
    have hYâ‚ : Yâ‚ âˆˆ ğ”… := .inr âŸ¨hYâ‚_cl, hcâ‚âŸ©
    have hYâ‚‚ : Yâ‚‚ âˆˆ ğ”… := .inr âŸ¨hYâ‚‚_cl, hcâ‚‚âŸ©
    have hYâ‚_inter_B : Yâ‚ âˆ© â‹‚â‚€ B = âˆ… := by grind
    have hYâ‚‚_inter_B : Yâ‚‚ âˆ© â‹‚â‚€ B = âˆ… := by grind
    -- By maximality of `B`, neither `B âˆª {Yâ‚}` nor `B âˆª {Yâ‚‚}` is contained in `ğ’®`
    have hYâ‚B : insert Yâ‚ B âˆ‰ ğ’® := by
      intro hYâ‚B
      grind [show insert Yâ‚ B âŠ† B from hB.le_of_ge hYâ‚B (Set.subset_insert Yâ‚ B)]
    have hYâ‚‚B : insert Yâ‚‚ B âˆ‰ ğ’® := by
      intro hYâ‚‚B
      grind [show insert Yâ‚‚ B âŠ† B from hB.le_of_ge hYâ‚‚B (Set.subset_insert Yâ‚‚ B)]
    dsimp [ğ’®] at hYâ‚B hYâ‚‚B
    simp only [Set.insert_subset_iff, hYâ‚, hB.prop.1, and_self, Set.sInter_insert, hYâ‚_inter_B,
      and_true, true_and, not_forall, Set.not_nonempty_iff_eq_empty, hYâ‚‚, hYâ‚‚_inter_B] at hYâ‚B hYâ‚‚B
    -- Hence there exist finitely many `{Aáµ¢} âŠ† B` such that `Z âˆ© â‹‚ Aáµ¢ = âˆ…`.
    obtain âŸ¨Aâ‚, hAâ‚, hAâ‚', hAâ‚''âŸ© := hYâ‚B
    obtain âŸ¨Aâ‚‚, hAâ‚‚, hAâ‚‚', hAâ‚‚''âŸ© := hYâ‚‚B
    have : Z âˆ© â‹‚â‚€ (Aâ‚ \ {Yâ‚} âˆª Aâ‚‚ \ {Yâ‚‚}) = âˆ… := by grind
    rw [â† Set.not_nonempty_iff_eq_empty] at this
    apply this
    rw [Set.inter_comm]
    refine IsCompact.nonempty_inter_sInter ?_ (fun _ hb â†¦ hb.2) fun F hsub hF â†¦ ?_
    Â· apply isCompact_sInter_of_subset_constructibleTopologySubbasis _ (hAâ‚'.diff.union hAâ‚‚'.diff)
      grind [hB.prop, Set.union_subset_iff]
    Â· rw [â† Set.sInter_union]
      refine hB.prop.2.1 (_ âˆª F) ?_ <| (hAâ‚'.diff.union hAâ‚‚'.diff).union hF
      grind [Set.diff_singleton_subset_iff, Set.union_subset_iff]
